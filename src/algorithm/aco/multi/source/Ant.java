package algorithm.aco.multi.source;

import Utils.CollectionUtils;
import Utils.MathUtils;
import Utils.Pair;
import algorithm.OurLocalSearch;
import algorithm.aco.pheromone.IPheromone;
import graph.version2.Graph;

import java.util.*;

/**
 * Created by seal on 7/18/15.
 *
 * @author Muztaba Hasanat
 */
public class Ant {
    private Graph graph;
    private IPheromone pheromone;

    Deque<Integer> queue;

    Random random = new Random();
    private List<Integer> sourceList;
    private Set<Integer> visited = new HashSet<>();
    private Set<Pair<Integer, Integer>> occupiedLink = new HashSet<>();
    public Set<Pair<Integer, Integer>> visitedLink = new HashSet<>();

    private int currentNode;
    private double power;

    private double totalLoadShedding;
    private double totalResidual;


    public static final double ALPHA = 3;
    public static final double BETA = 2;
    public final double SCALING_FACTOR;

    public Ant(final Graph graph) {
        this.graph = graph;
        SCALING_FACTOR = MathUtils.nextBigDigit(graph.getMaxDemand());
        Set<Integer> sourceSet = graph.getSourceList();
        // source set converted to List.
        this.sourceList = CollectionUtils.toList(sourceSet);
    }

    public void initiate(IPheromone pheromone) {
        graph.reset();
        occupiedLink.clear();
        visitedLink.clear();
        visited.clear();
        this.pheromone = pheromone;
        shuffleSourceList();

        /* Console Output */
        System.out.println("Start ACO Algorithm");

        for (int sourceNode : sourceList) {
            queue = new ArrayDeque<>();
            queue.add(sourceNode);
            while (!queue.isEmpty()) {
                int _currentNode = queue.poll();
                setupAnt(_currentNode);
                moveAnt();
            }
        }
        double prevLoadShedding = graph.calculateTotalLoadShedding();
        double prevResidual = graph.calculateTotalResidual();
        graph.validationCheck();

        OurLocalSearch localSearch = new OurLocalSearch();
        /* Console Output */
        System.out.println("Start Local Search");
        localSearch.initiate(graph, 200);

        graph.validationCheck();

        this.totalLoadShedding = graph.calculateTotalLoadShedding();
        this.totalResidual = graph.calculateTotalResidual();
    }
    /**
     * When the ant is being setup at the first time on source node or a node that has
     * residual electricity this method get the electricity from the node and assign to
     * the ant's power.
     * It also check if the node is source node and visited before then it take the residual
     * electricity from the source node. Otherwise it take the electricity from the node that
     * is generated by this node.
     * If the node is demand node then directly get the residua electricity.
     * Only the node is source node then the node will mark visited. Demand node will mark visited
     * in the moveAnt method.
     * Because of getting the full power from the current node there is no residual in the node.
     * So the residual set `0`.
     *
     * @param node first node where some power has.
     */
    private void setupAnt(final int node) {
        if (graph.isSourceNode(node)) {
            if (visited.contains(node)) {
                this.power = graph.getResidual(node);
            } else {
                this.power = graph.getPower(node);
            }
            visited.add(node);
        } else {
            this.power = graph.getResidual(node);
        }
        graph.setResidual(node, 0);
        this.currentNode = node;
    }

    /**
     * Every time initiate the ant the source list will be shuffled.
     * Because ant will not place in source node in any order.
     */
    private void shuffleSourceList() {
        Collections.shuffle(this.sourceList);
    }


    /**
     * This inner class use for finding out the maximum probability node.
     */
    private static class MaxProbNode implements Comparable<MaxProbNode> {
        private int nodeNumber;
        private double probability;

        public MaxProbNode(int nodeNumber, double probability) {
            this.nodeNumber = nodeNumber;
            this.probability = probability;
        }

        @Override
        public int compareTo(MaxProbNode node) {
            return Double.compare(node.probability, this.probability);
        }
    }

    private boolean moveAnt() {
        while (this.power > 0) {
            if (!graph.isSourceNode(this.currentNode)) {
                visited.add(this.currentNode);
                operationOnDemandNode();
            }
            // After giving power to a node if the ant's power will zero then the ant stop moving.
            if (this.power <= 0) {
                return false;
            }
            int nextNode = nextNodeSelection();

            if (nextNode < 0) {
                graph.addResidual(this.currentNode, this.power);
                return false;
            }
            occupiedLink.add(Pair.makePair(this.currentNode, nextNode));
            occupiedLink.add(Pair.makePair(nextNode, this.currentNode));

            double linkCapacity = graph.getCapacity(this.currentNode, nextNode);
            double avgFlowOfLink = avgFlowOfLink(nextNode);
            double flow = Math.min(Math.min(linkCapacity, avgFlowOfLink), this.power);

            if (power > flow) {
                double residual = power - flow;
                graph.addResidual(this.currentNode, residual);
                power = flow;
                queue.add(this.currentNode);
            } else {
                flow = power;
            }

            double validFlow = graph.checkFlowConstraint(currentNode, nextNode, flow);
            if (validFlow < 0) {
                flow -= Math.abs(validFlow);
                graph.addResidual(this.currentNode, Math.abs(validFlow));
            }

            assert (flow == 0) : "Flow should not be '0'";

            graph.setFlow(this.currentNode, nextNode, flow);
            graph.setDegreeMap(this.currentNode, nextNode);
            graph.setVisitedNumber(this.currentNode);
            visitedLink.add(Pair.makePair(currentNode, nextNode));
            this.currentNode = nextNode;
        }
        return false;
    }

    /**
     * When the next has been selected then this method will try to
     * assume what will be the incoming edges. so the the demand of that
     * node will be divided into those incoming link.
     *
     * @param nextNode to where this ant will go from current node.
     * @return the average flow of a link that are currently available.
     */
    private double avgFlowOfLink(int nextNode) {
        int unusedLink = graph.degreeUsed(nextNode);
        int probIncomingLink = (int) Math.ceil(unusedLink / 2);
        double loadSheddingNextNode = graph.getLoadShedding(nextNode);
        if (probIncomingLink != 0) {
            if (loadSheddingNextNode != 0) {
                return loadSheddingNextNode / probIncomingLink;
            } else {
                return Double.MAX_VALUE;
            }
        } else {
            if (loadSheddingNextNode != 0) {
                return loadSheddingNextNode;
            } else {
                return Double.MAX_VALUE;
            }
        }
    }

    /**
     * This method give the power to the demand node. Get the load shedding of the current node.
     * Take the minimum between current ant power and the current node load shedding. Generate power
     * power and set to the power to the current node. Then deduct the generated power from the ant's power.
     * Ant's power will not negative.
     */
    private void operationOnDemandNode() {
        double loadShedding = graph.getLoadShedding(this.currentNode);
        double generatePower = Math.min(power, loadShedding) * random.nextDouble();
        graph.addPower(this.currentNode, generatePower);
        this.power -= generatePower;
    }

    private int nextNodeSelection() {
        PriorityQueue<MaxProbNode> probNodes = new PriorityQueue<>();
        double denominator = calculateDenominator();

        if (denominator <= 0) {
            return -1;
        }

        for (Graph.VertexInfo itr : graph.extractVertexInfo(this.currentNode)) {
            int V = itr.nodeNumber;
            if (occupiedLink.contains(Pair.makePair(this.currentNode, V))) {
                continue;
            }
            double loadShedding = (itr.loadShedding == 0.0) ? 0.1 : itr.loadShedding;
//            if (visited.contains(V)) {
//                continue;
//            }
//            if (graph.isSourceNode(V)) {
//                continue;
//            }

            double pheromone = this.pheromone.get(currentNode, V);
            double nn = loadShedding / SCALING_FACTOR;
            double p = probTo(pheromone, nn, denominator);
            MaxProbNode maxProbNode = new MaxProbNode(V, p);
            probNodes.add(maxProbNode);
        }
        int nextNode = -1;
        if (!probNodes.isEmpty()) {
            nextNode = probNodes.peek().nodeNumber;
        }
        return nextNode;
    }

    private double calculateDenominator() {
        double sum = 0.0;
        for (Graph.VertexInfo itr : graph.extractVertexInfo(this.currentNode)) {
            int V = itr.nodeNumber;
            if (occupiedLink.contains(Pair.makePair(this.currentNode, V))) {
                continue;
            }
            double loadShedding = (itr.loadShedding == 0) ? 0.1 : itr.loadShedding;
            // Scale the load shedding.
            loadShedding /= SCALING_FACTOR;
            sum += Math.pow(loadShedding, BETA) * Math.pow(pheromone.get(currentNode, V), ALPHA);
        }
        return sum;
    }

    private double probTo(double pheromone, double nn, double denominator) {
        double nominator = Math.pow(pheromone, ALPHA) * Math.pow(nn, BETA);
        return nominator / denominator;
    }

    /**
     * Return the total load shedding of the graph that this ant
     * has visited.
     *
     * @return total load shedding of the graph that this ant visited.
     */
    public double getTotalLoadShedding() {
        return this.totalLoadShedding;
    }

    /**
     * This method return the total residual in the graph that this ant travel.
     *
     * @return total residual of the graph.
     */
    public double getTotalResidual() {
        return this.totalResidual;
    }

    /**
     * This method return the summation of the total load shedding and the total residual of the graph
     * that has been visited by the current ant.
     *
     * @return load shedding + residual.
     */
    public double quality() {
        return totalResidual + totalLoadShedding;
    }

    //===========================================//
    //==================DEBUG====================//
    //===========================================//
    public List<Pair<Integer, Integer>> visitedLinkOrder = new ArrayList<>();

    public void printVisitedNode() {
        for (int i : visited) {
            System.out.println(i);
        }
    }

    public void printVisitedLink() {
        for (Pair<Integer, Integer> i : visitedLinkOrder) {
            System.out.println(i.first + " " + i.second);
        }
    }

    public void printDegree() {
        graph.printDegree(this.visited);
    }

    public void printNextNode(int node) {
        System.out.println(node);
    }

    public int getVisitedNodeNumber() {
        return this.visited.size();
    }

    public void printGraph() {
        this.graph.print();
    }
}
